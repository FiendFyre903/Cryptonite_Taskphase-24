# Some assembly required 3

**Flag:** `picoCTF{f41f60eaaa60d4d980fac90e050a0e49}`

- **step 1**

    Similar to the previous challenge, this challenge had encrypted text in the same wasm file, but this time there were two strings as well as a new **copy** function.

    `\9dn\93\c8\b2\b9A\8b\c1\c5\dca\c6\97\94\8cf\91\91\c1\893\94\9e\c9\dda\91\c4\c8\ddb\c0\92\c1\8c7\95\93\c8\90`

    and

    `\f1\a7\f0\07\ed`

- **step 2**

    I decompiled the wasm code using WABT(Web Assembly Binary Toolkit) and tried to made sense of the copy function as well as searching for anything else that was different from the previous questions. 

    ```bash
    fiendfyre@fedora:~/Downloads/CTF_dump$ wasm-decompile 945fef6e
    export memory memory(initial: 2, max: 0);

    global g_a:int = 66864;
    export global input:int = 1072;
    export global key:int = 1067;
    export global dso_handle:int = 1024;
    export global data_end:int = 1328;
    export global global_base:int = 1024;
    export global heap_base:int = 66864;
    export global memory_base:int = 0;
    export global table_base:int = 1;

    table T_a:funcref(min: 1, max: 1);

    data d_nAaf3ab7(offset: 1024) =
    "\9dn\93\c8\b2\b9A\8b\c1\c5\dca\c6\97\94\8cf\91\91\c1\893\94\9e\c9\dda\91"
    "\c4\c8\ddb\c0\92\c1\8c7\95\93\c8\90\00\00";
    data d_b(offset: 1067) = "\f1\a7\f0\07\ed";

    export function wasm_call_ctors() {
    }

    export function strcmp(a:int, b:int):int {
    var c:int = g_a;
    var d:int = 32;
    var e:int = c - d;
    e[6]:int = a;
    e[5]:int = b;
    var f:int = e[6]:int;
    e[4]:int = f;
    var g:int = e[5]:int;
    e[3]:int = g;
    loop L_b {
        var h:ubyte_ptr = e[4]:int;
        var i:int = 1;
        var j:int = h + i;
        e[4]:int = j;
        var k:int = h[0];
        e[11]:byte = k;
        var l:ubyte_ptr = e[3]:int;
        var m:int = 1;
        var n:int = l + m;
        e[3]:int = n;
        var o:int = l[0];
        e[10]:byte = o;
        var p:int = e[11]:ubyte;
        var q:int = 255;
        var r:int = p & q;
        if (r) goto B_c;
        var s:int = e[11]:ubyte;
        var t:int = 255;
        var u:int = s & t;
        var v:int = e[10]:ubyte;
        var w:int = 255;
        var x:int = v & w;
        var y:int = u - x;
        e[7]:int = y;
        goto B_a;
        label B_c:
        var z:int = e[11]:ubyte;
        var aa:int = 255;
        var ba:int = z & aa;
        var ca:int = e[10]:ubyte;
        var da:int = 255;
        var ea:int = ca & da;
        var fa:int = ba;
        var ga:int = ea;
        var ha:int = fa == ga;
        var ia:int = 1;
        var ja:int = ha & ia;
        if (ja) continue L_b;
    }
    var ka:int = e[11]:ubyte;
    var la:int = 255;
    var ma:int = ka & la;
    var na:int = e[10]:ubyte;
    var oa:int = 255;
    var pa:int = na & oa;
    var qa:int = ma - pa;
    e[7]:int = qa;
    label B_a:
    var ra:int = e[7]:int;
    return ra;
    }

    export function check_flag():int {
    var a:int = 0;
    var b:int = 1072;
    var c:int = 1024;
    var d:int = strcmp(c, b);
    var e:int = d;
    var f:int = a;
    var g:int = e != f;
    var h:int = -1;
    var i:int = g ^ h;
    var j:int = 1;
    var k:int = i & j;
    return k;
    }

    function copy(a:int, b:int) {
    var c:int = g_a;
    var d:int = 16;
    var e:int_ptr = c - d;
    e[3] = a;
    e[2] = b;
    var f:int = e[3];
    if (eqz(f)) goto B_a;
    var g:int = 4;
    var h:int = e[2];
    var i:int = 5;
    var j:int = h % i;
    var k:ubyte_ptr = g - j;
    var l:int = k[1067];
    var m:int = 24;
    var n:int = l << m;
    var o:int = n >> m;
    var p:int = e[3];
    var q:int = p ^ o;
    e[3] = q;
    label B_a:
    var r:int = e[3];
    var s:byte_ptr = e[2];
    s[1072] = r;
    }

    ```

    This gave me C-like pseudocode that was easier to understand. What the copy function was doing, was basically taking each individual character from the first string and XOR'ing it with a character from the second string. Which character was decided by the index of the first character using the formula `(4 - (i % 5))` #`i` being the index. 

- **step 3**

    Now it was a simle matter of reversing the encryption. Luckily XOR is very easy to reverse since XOR'ing anything twice gives the original value.

    So I wrote the following python script to get the flag.

    ```python
    a = "\x9dn\x93\xc8\xb2\xb9A\x8b\xc1\xc5\xdca\xc6\x97\x94\x8cf\x91\x91\xc1\x893\x94\x9e\xc9\xdda\x91\xc4\xc8\xddb\xc0\x92\xc1\x8c7\x95\x93\xc8\x90"
    b = "\xf1\xa7\xf0\x07\xed"

    for i in range(len(a)):
        print(chr(ord(a[i])^ord(b[4-i%5])), end = "")

    ```
    

**What I learned:**

1. A rough understanding of webassembly raw code.
2. How to decompile WASM. 
3. Writing a simple script to reverse XOR.
4. Using `wget` to download files from a website.

**Other incorrect methods I tried:**

- Using just the two hex strings I tried various ways to decode it using cyber chef and other such tools but none of them worked. 
- Initially I thought of deobfuscating the JS code but since it was unnecessary for the previous 2 questions, i stopped after a little bit. However i did find a good tool that helps in deobfuscating JS.

**References**

- https://github.com/WebAssembly/wabt
- https://deobfuscate.io/
